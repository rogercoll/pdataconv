{%- macro smart_title_case(text) -%}
{%- for i in range(0, text | length) -%}
    {%- if i == 0 or text[i-1] in ['.', '_'] -%}
        {{ text[i] | upper }}
    {%- elif not text[i] in ['.', '_'] -%}
        {{ text[i] }}
    {%- endif -%}
{%- endfor -%}
{%- endmacro -%}
{%- macro attribute_struct_field(attr) %}{{ smart_title_case(attr.name) }} {% if attr.requirement_level != "required" %}*{% endif %}{{attr.type | map_text("attribute_type_value") }}{%- endmacro -%}
package metadata

import (
	"go.opentelemetry.io/collector/pdata/pmetric"
)

// DO NOT MODIFY: This code is autogenerated.
// See templates/registry/go/metrics.go.j2.

{# Map SemConv instrument type to pdata #}
{% set InstrMap = {
   "histogram": "Histogram",
   "gauge": "Gauge",
   "counter": "Sum",
   "updowncounter": "Sum",
} %}

{# Map default monotonicity based on instrument type #}
{% set default_monotonic_map = {
    "counter": true,
    "updowncounter": false
} %}


{# Define the default temporality per instrument #}
{% set default_temporality_map = {
    "counter": "cumulative",
    "updowncounter": "cumulative",
    "histogram": "delta",
} %}

{% for metric in ctx %}
{% set metric_name = smart_title_case(metric.metric_name) %}
{% set PdataInstr = InstrMap[metric.instrument] %}

type metric{{ metric_name }} struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills {{ metric_name }} metric with initial data.
func (m *metric{{ metric_name }}) init() {
	m.data.SetName("{{ metric_name }}")
	m.data.SetDescription("{{ metric.brief }}")
	m.data.SetUnit("{{ metric.unit }}")
	m.data.SetEmpty{{ PdataInstr }}()

	{# Only set monotonicity for instrument types that map to Sum monotonic #}
	{% if metric.instrument in ["counter"] %}
	    {# Emit SetIsMonotonic() with user override if available, otherwise fall back to type default #}
	    m.data.{{ PdataInstr }}().SetIsMonotonic({{ metric.annotations.monotonic if metric.annotations.monotonic is not none else default_monotonic_map[metric.instrument] | lower }})
	{% endif %}

	{# Only set aggregated for instrument types that map to histogram and sum #}
	{% if metric.instrument == "histogram" or metric.instrument == "counter" or metric.instrument == "updowncounter" %}
	    {% set temporality_key = metric.annotations.aggregation_temporality if metric.annotations.aggregation_temporality is not none else default_temporality_map[metric.instrument] %}

	    {% if temporality_key == "cumulative" or temporality_key == "delta" %}
		m.data.{{ PdataInstr }}().SetAggregationTemporality(pmetric.AggregationTemporality{{ temporality_key | capitalize }})
	    {% endif %}
	{% endif %}

	{# Only emit EnsureCapacity if there are attributes defined #}
	{% if metric.attributes and metric.attributes | length > 0 %}
	    m.data.{{ PdataInstr }}().DataPoints().EnsureCapacity(m.capacity)
	{% endif %}
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metric{{ metric_name }}) updateCapacity() {
	if m.data.{{ PdataInstr }}().DataPoints().Len() > m.capacity {
		m.capacity = m.data.{{ PdataInstr }}().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metric{{ metric_name }}) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.{{ PdataInstr }}().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetric{{ metric_name }}(cfg MetricConfig) metric{{ metric_name }} {
	m := metric{{ metric_name }}{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

{% endfor %}
