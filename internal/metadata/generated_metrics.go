package metadata

import (
	"go.opentelemetry.io/collector/pdata/pmetric"
)

// DO NOT MODIFY: This code is autogenerated.
// See templates/registry/go/metrics.go.j2.

type metricContainerCpuUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ContainerCpuUsage metric with initial data.
func (m *metricContainerCpuUsage) init() {
	m.data.SetName("ContainerCpuUsage")
	m.data.SetDescription("Container CPU consumed time, as reported by the container runtime")
	m.data.SetUnit("By")
	m.data.SetEmptySum()

	m.data.Sum().SetIsMonotonic(true)

	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)

	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)

}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerCpuUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerCpuUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerCpuUsage(cfg MetricConfig) metricContainerCpuUsage {
	m := metricContainerCpuUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ContainerMemoryUsage metric with initial data.
func (m *metricContainerMemoryUsage) init() {
	m.data.SetName("ContainerMemoryUsage")
	m.data.SetDescription("Memory usage of the container")
	m.data.SetUnit("By")
	m.data.SetEmptySum()

	m.data.Sum().SetIsMonotonic(false)

	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)

	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)

}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryUsage(cfg MetricConfig) metricContainerMemoryUsage {
	m := metricContainerMemoryUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}
